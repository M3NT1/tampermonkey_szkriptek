// ==UserScript==
// @name         TER - Mentett emberek szabadságának megtekintése2 (csoportok mentése)
// @namespace    http://tampermonkey.net/
// @version      1.1
// @description  Hozzáadott csoport/név kezelés + localStorage mentés; indítás csoport kiválasztással
// @author       M3NT1
// @match        https://ter.ulyssys.hu/ter/leave/lquery*
// @grant        none
// @run-at       document-ready
// ==/UserScript==

(function () {
    'use strict';

    // --- KONFIG ---
    const CONFIG = {
        DEBUG: false,
        START_ID: 'form:tabView:startDate_input',
        END_ID: 'form:tabView:endDate_input',
        TAB_HREF: '#form:tabView:tab2',
        MAX_WAIT_MS: 7000,
        RETRY_COUNT: 3,
        NAMES_STORAGE_KEY: 'tm_ter_names',           // backward compatibility (single list)
        GROUPS_STORAGE_KEY: 'tm_ter_name_groups',   // stores { groupName: [name1,name2,...], ... }
        DEFAULT_GROUP: 'Alap'
    };

    function log(...args) { if (CONFIG.DEBUG) console.log('[TER_tavollet_betolto]', ...args); }

    // --- EREDTI FÜGGVÉNYEK (minimálisan módosítva) ---
    function waitForCondition(checkFn, timeout = CONFIG.MAX_WAIT_MS, interval = 150) {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            (function poll() {
                try { if (checkFn()) return resolve(true); } catch (e) {}
                if (Date.now() - start > timeout) return reject(new Error('timeout'));
                setTimeout(poll, interval);
            })();
        });
    }

    function formatDateForField(d) {
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${yyyy}.${mm}.${dd}.`;
    }

    function byId(id) { return document.getElementById(id); }

    function triggerChange(el) {
        if (!el) return;
        if (window.jQuery) {
            try { window.jQuery(el).val(el.value).trigger('change'); } catch (e) {}
        }
        el.dispatchEvent(new Event('input', { bubbles: true }));
        el.dispatchEvent(new Event('change', { bubbles: true }));
    }

    function isStatusDialogVisible() {
        try {
            const dlg = document.getElementById('form:statusDialog');
            if (!dlg) return false;
            const cs = window.getComputedStyle(dlg);
            if (cs.display === 'none' || cs.visibility === 'hidden') return false;
            if (dlg.getAttribute('aria-hidden') === 'true') return false;
            return true;
        } catch (e) { return false; }
    }

    function waitForStatusDialogHidden(timeout = CONFIG.MAX_WAIT_MS) {
        return waitForCondition(() => !isStatusDialogVisible(), timeout, 150);
    }

    async function clickTabAndWait() {
        const anchor = document.querySelector(`a[href=\"${CONFIG.TAB_HREF}\"]`);
        if (!anchor) throw new Error('Tab anchor not found');
        const li = anchor.closest('li');
        log('Clicking tab anchor', anchor, 'parent li:', li);
        anchor.click();
        await waitForCondition(() => {
            try { return li && (li.classList.contains('ui-tabs-selected') || li.classList.contains('ui-state-active') || li.getAttribute('aria-selected') === 'true'); } catch (e) { return false; }
        }).catch(() => { log('Tab did not become active within timeout'); });
    }

    async function setDateWithValidation(inputId, valueStr) {
        const input = byId(inputId);
        if (!input) throw new Error(`Input not found: ${inputId}`);
        for (let attempt = 1; attempt <= CONFIG.RETRY_COUNT; attempt++) {
            log(`Setting ${inputId} attempt ${attempt} ->`, valueStr);
            try { input.value = valueStr; } catch (e) { log('Failed to set value directly', e); }
            triggerChange(input);
            try { await waitForStatusDialogHidden(CONFIG.MAX_WAIT_MS); } catch (e) { log('Status dialog wait failed/timeout'); }
            try {
                await waitForCondition(() => input.value === valueStr, CONFIG.MAX_WAIT_MS);
                await new Promise(r => setTimeout(r, 150));
                log(`${inputId} successfully set to`, input.value);
                return true;
            } catch (e) {
                log(`${inputId} not updated yet (attempt ${attempt})`);
                await new Promise(r => setTimeout(r, 250));
            }
        }
        throw new Error(`Failed to set input ${inputId} to ${valueStr}`);
    }

    // --- AUTOCOMPLETE / NÉV SELEKCIÓ (eredeti logika megtartva) ---
    function findAutocompletePanel() { return document.querySelector('[id*="j_idt263_panel"], .ui-autocomplete-panel'); }
    function findHiddenSelect() { return document.querySelector('[id*="j_idt263_hinput"]'); }

    async function selectAutocompleteName(name) {
        // (A teljes eredeti megvalósítás változatlanul beilleszthető – itt röviden használjuk a meglévőt)
        log('Selecting autocomplete name:', name);
        const findInput = () => {
            const wrapper = document.querySelector('[id*="j_idt263"]');
            if (!wrapper) return null;
            return wrapper.querySelector('input[type="text"]');
        };
        const input = findInput();
        if (!input) throw new Error('Autocomplete input not found');

        let panel = null;
        const widget = (window.PF && typeof PF === 'function') ? PF('users') : null;

        for (let openAttempt = 1; openAttempt <= 4; openAttempt++) {
            try { input.focus(); input.value = name; } catch (e) { log('set input failed', e); }
            try {
                if (widget) {
                    if (widget.input && typeof widget.input.val === 'function') widget.input.val(name);
                    if (typeof widget.search === 'function') widget.search(name);
                    if (widget.panel) panel = widget.panel.get(0);
                }
            } catch (e) { log('widget search failed', e); }
            triggerChange(input);
            await new Promise(r => setTimeout(r, 260));
            panel = panel || findAutocompletePanel();
            if (panel && panel.querySelectorAll('.ui-autocomplete-item').length > 0) break;

            // simulate typing
            try {
                input.focus();
                input.value = '';
                for (let i = 0; i < name.length; i++) {
                    const ch = name.charAt(i);
                    input.value += ch;
                    triggerChange(input);
                    input.dispatchEvent(new KeyboardEvent('keydown', { key: ch, bubbles: true }));
                    input.dispatchEvent(new KeyboardEvent('keyup', { key: ch, bubbles: true }));
                    await new Promise(r => setTimeout(r, 60));
                }
            } catch (e) { log('typing failed', e); }

            await new Promise(r => setTimeout(r, 260));
            panel = panel || findAutocompletePanel();
            if (panel && panel.querySelectorAll('.ui-autocomplete-item').length > 0) break;
        }

        if (!panel || panel.querySelectorAll('.ui-autocomplete-item').length === 0) throw new Error('Autocomplete panel did not appear');

        try {
            input.focus();
            input.dispatchEvent(new KeyboardEvent('keydown', { key: 'ArrowDown', keyCode: 40, which: 40, bubbles: true }));
            await new Promise(r => setTimeout(r, 80));
            input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', keyCode: 13, which: 13, bubbles: true }));
        } catch (e) { log('keyboard select failed', e); }

        await new Promise(r => setTimeout(r, 150));

        const hselect = findHiddenSelect();
        const wrapperAfter = document.querySelector('[id*="j_idt263"]');
        const ok = await waitForCondition(() => {
            if (hselect) {
                const opts = Array.from(hselect.options || []);
                if (opts.some(o => (o.text || o.label || '').includes(name))) return true;
            }
            if (wrapperAfter) {
                const tokens = Array.from(wrapperAfter.querySelectorAll('li')).filter(li => !li.querySelector('input'));
                if (tokens.some(t => (t.textContent || '').trim().includes(name))) return true;
            }
            return false;
        }, 700).catch(() => false);

        if (ok) {
            try { await waitForStatusDialogHidden(CONFIG.MAX_WAIT_MS); } catch (e) {}
            return true;
        }

        const items = Array.from(panel.querySelectorAll('.ui-autocomplete-item'));
        let item = items.find(it => (it.getAttribute('data-item-label') || '').trim() === name);
        if (!item) item = items.find(it => it.textContent && it.textContent.includes(name));
        if (!item) throw new Error('Autocomplete item not found for: ' + name);

        try {
            ['mousemove', 'mouseover', 'mousedown', 'mouseup', 'click'].forEach(type => {
                const evt = new MouseEvent(type, { bubbles: true, cancelable: true, view: window });
                item.dispatchEvent(evt);
            });
            const inner = item.querySelector('span') || item.firstChild;
            if (inner && inner !== item) {
                ['mousemove', 'mouseover', 'mousedown', 'mouseup', 'click'].forEach(type => {
                    const evt = new MouseEvent(type, { bubbles: true, cancelable: true, view: window });
                    inner.dispatchEvent(evt);
                });
            }
        } catch (e) {
            log('mouse events failed', e);
            try { item.click(); } catch (e2) {}
        }

        try { await waitForStatusDialogHidden(CONFIG.MAX_WAIT_MS); } catch (e) {}
        await waitForCondition(() => {
            const hs = findHiddenSelect();
            if (hs) {
                const opts = Array.from(hs.options || []);
                if (opts.some(o => (o.text || o.label || '').includes(name))) return true;
            }
            const w = document.querySelector('[id*="j_idt263"]');
            if (w) {
                const tokens = Array.from(w.querySelectorAll('li')).filter(li => !li.querySelector('input'));
                return tokens.some(t => (t.textContent || '').trim().includes(name));
            }
            return false;
        }, CONFIG.MAX_WAIT_MS).catch(() => {});

        log('Selected autocomplete name done:', name);
        return true;
    }

    async function selectNamesSequentially(names) {
        for (let i = 0; i < names.length; i++) {
            const n = names[i];
            showToast(`Kiválasztás: ${n}`);
            try { await selectAutocompleteName(n); } catch (e) { log('Failed to select', n, e); showToast('Hiba: ' + n + ' → ' + (e.message || e)); }
            await new Promise(r => setTimeout(r, 350));
        }
        showToast('Nevek feldolgozva');
    }

    function showToast(msg, ms = 3000) {
        const n = document.createElement('div');
        n.textContent = msg;
        n.style.cssText = 'position:fixed;top:20px;right:20px;background:#14892c;color:#fff;padding:10px 14px;border-radius:4px;z-index:20001;font-size:13px';
        document.body.appendChild(n);
        setTimeout(() => n.remove(), ms);
    }

    // --- FŐ SEQUENCE (eredeti, változatlan) ---
    async function runSequence() {
        try {
            await clickTabAndWait();
            const today = new Date();
            const end = new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000);
            const startStr = formatDateForField(today);
            const endStr = formatDateForField(end);

            await setDateWithValidation(CONFIG.START_ID, startStr);
            await new Promise(r => setTimeout(r, 400));

            let success = false;
            for (let attempt = 1; attempt <= CONFIG.RETRY_COUNT; attempt++) {
                try { await setDateWithValidation(CONFIG.END_ID, endStr); } catch (e) { log('set end failed', e); }
                await new Promise(r => setTimeout(r, 500));
                const endInput = document.getElementById(CONFIG.END_ID);
                const currentEnd = endInput ? endInput.value : null;
                log('Current end after set attempt:', currentEnd);
                if (currentEnd === endStr) { success = true; break; }
                try { await setDateWithValidation(CONFIG.START_ID, startStr); } catch (e) { log('reapply start failed', e); }
                await new Promise(r => setTimeout(r, 250));
            }

            if (!success) throw new Error(`End date did not stabilize to ${endStr} after ${CONFIG.RETRY_COUNT} attempts`);

            showToast('Dátumok beállítva: ' + startStr + ' → ' + endStr);
            log('Sequence completed');
        } catch (err) {
            log('Sequence failed:', err);
            showToast('Hiba a dátumok beállításakor: ' + (err.message || err));
        }
    }

    // --- CSOPORTOK / NÉVEK MENTÉSE (localStorage) ---
    function readGroups() {
        const raw = localStorage.getItem(CONFIG.GROUPS_STORAGE_KEY) || '{}';
        try { return JSON.parse(raw); } catch (e) { return {}; }
    }
    function writeGroups(obj) { localStorage.setItem(CONFIG.GROUPS_STORAGE_KEY, JSON.stringify(obj)); }

    // Visszafelé kompatibilitás: ha régi NAMES_STORAGE_KEY is van, becsomagoljuk alap csapatba
    function migrateLegacyNames() {
        const raw = localStorage.getItem(CONFIG.NAMES_STORAGE_KEY);
        if (raw && !localStorage.getItem(CONFIG.GROUPS_STORAGE_KEY)) {
            const arr = raw.split(/\r?\n|,/).map(s => s.trim()).filter(Boolean);
            const g = {}; g[CONFIG.DEFAULT_GROUP] = arr;
            writeGroups(g);
            localStorage.removeItem(CONFIG.NAMES_STORAGE_KEY);
            log('Migrated legacy names into groups');
        }
    }

    // --- UI: létrehozás, betöltés, mentés, indítás ---
    function createControlButton() {
        // Ha már van, ne duplikáljuk
        if (document.getElementById('tm-ter-controls')) return buildControlsReference();

        // container
        const container = document.createElement('div');
        container.id = 'tm-ter-controls';
        container.style.cssText = 'position:fixed;top:80px;right:18px;z-index:20000;display:flex;gap:6px;flex-direction:column;align-items:flex-end;font-family:Arial,Helvetica,sans-serif';

        // group select
        const groupSelect = document.createElement('select');
        groupSelect.id = 'tm-ter-group-select';
        groupSelect.style.cssText = 'padding:6px;border-radius:4px;border:1px solid #ccc;background:white;font-size:12px';
        refreshGroupSelectOptions(groupSelect);

        // settings (open manager)
        const settingsBtn = document.createElement('button');
        settingsBtn.id = 'tm-ter-names-settings';
        settingsBtn.textContent = '⚙';
        settingsBtn.title = 'Csoportok kezelése';
        settingsBtn.style.cssText = 'padding:6px 8px;background:#444;color:white;border:none;border-radius:4px;cursor:pointer;font-size:13px';

        // main run button (indítás)
        const mainBtn = document.createElement('button');
        mainBtn.id = 'tm-ter-view-saved-people2';
        mainBtn.textContent = 'Indítás (kiválasztott csoport)';
        mainBtn.style.cssText = 'padding:8px 12px;background:#205081;color:white;border:none;border-radius:4px;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,0.2)';

        // apply names button (kitölti a nevek mezőt a kódban lévő helyre, majd meghívja az alap apply)
        const applyNamesBtn = document.createElement('button');
        applyNamesBtn.id = 'tm-ter-apply-names';
        applyNamesBtn.textContent = 'Nevek alkalmazása (kijelölt csoport)';
        applyNamesBtn.style.cssText = 'padding:6px 10px;background:#2d6ca2;color:white;border:none;border-radius:4px;cursor:pointer;font-size:12px';

        // top row
        const topRow = document.createElement('div');
        topRow.style.cssText = 'display:flex;gap:6px;align-items:center';
        topRow.appendChild(groupSelect);
        topRow.appendChild(settingsBtn);

        container.appendChild(topRow);
        container.appendChild(mainBtn);
        container.appendChild(applyNamesBtn);

        // insert into page if possible, else body
        const dtHeader = document.querySelector('.ui-datatable-header');
        if (dtHeader) {
            const wrapper = document.createElement('div');
            wrapper.className = 'tm-ter-button-wrapper';
            wrapper.style.cssText = 'display:inline-flex;gap:6px;align-items:center;margin-left:10px;';
            [mainBtn, applyNamesBtn, settingsBtn].forEach(b => {
                b.classList.add('ui-button', 'ui-widget', 'ui-state-default', 'ui-corner-all');
                b.style.margin = '0 5px 0 0';
                b.style.background = '';
                b.style.boxShadow = 'none';
            });
            wrapper.appendChild(mainBtn); wrapper.appendChild(applyNamesBtn); wrapper.appendChild(settingsBtn);
            dtHeader.appendChild(wrapper);
            // also add hidden select for reference to our container
            dtHeader.appendChild(container);
        } else {
            document.body.appendChild(container);
        }

        // események
        settingsBtn.addEventListener('click', openGroupManagerDialog);

        mainBtn.addEventListener('click', async () => {
            mainBtn.disabled = true;
            mainBtn.textContent = 'Futtatás...';
            try {
                // beállítjuk az aktuális csoport neveit a régi storage helyre kompatibilitásért
                const sel = document.getElementById('tm-ter-group-select');
                const group = sel ? sel.value : CONFIG.DEFAULT_GROUP;
                const names = readGroups()[group] || [];
                // írjuk át a NAMES_STORAGE_KEY-t (ahogy a régi kód használta)
                localStorage.setItem(CONFIG.NAMES_STORAGE_KEY, names.join('\n'));
                // majd meghívjuk az eredeti runSequence-t és utána a név kitöltést
                await runSequence();
                // ha szeretnéd, indíthatjuk a névkitöltést is automatikusan:
                if (names.length > 0) {
                    await selectNamesSequentially(names);
                }
            } catch (e) { log('main run failed', e); showToast('Hiba: ' + (e.message || e)); }
            mainBtn.disabled = false;
            mainBtn.textContent = 'Indítás (kiválasztott csoport)';
        });

        applyNamesBtn.addEventListener('click', async () => {
            const sel = document.getElementById('tm-ter-group-select');
            const group = sel ? sel.value : CONFIG.DEFAULT_GROUP;
            const groups = readGroups();
            const names = groups[group] || [];
            if (!names || names.length === 0) { showToast('A kiválasztott csoport üres vagy nem létezik'); return; }
            // kompatibilitás: írjuk felül a NAMES_STORAGE_KEY-et a régi kód számára
            localStorage.setItem(CONFIG.NAMES_STORAGE_KEY, names.join('\n'));
            // majd alkalmazzuk a neveket (az eredeti apply logikát használva)
            try {
                await selectNamesSequentially(names);
            } catch (e) { log('apply names failed', e); showToast('Hiba a nevek alkalmazásakor: ' + (e.message || e)); }
        });

        // amikor a select változik, frissítjük a helyi kompatibilis storage-t is és mutatunk üzenetet
        groupSelect.addEventListener('change', (e) => {
            const g = e.target.value;
            const groups = readGroups();
            const names = groups[g] || [];
            localStorage.setItem(CONFIG.NAMES_STORAGE_KEY, names.join('\n'));
            showToast('Csoport kiválasztva: ' + g, 1500);
        });

        return { container, main: mainBtn, applyNamesBtn, settingsBtn, groupSelect };
    }

    // helper ha már van: visszaad referenciákat
    function buildControlsReference() {
        return {
            container: document.getElementById('tm-ter-controls'),
            main: document.getElementById('tm-ter-view-saved-people2'),
            applyNamesBtn: document.getElementById('tm-ter-apply-names'),
            settingsBtn: document.getElementById('tm-ter-names-settings'),
            groupSelect: document.getElementById('tm-ter-group-select')
        };
    }

    function refreshGroupSelectOptions(selectEl) {
        // Ha nincs átadva select, keressük meg DOM-ból
        let sel = selectEl || document.getElementById('tm-ter-group-select');
        if (!sel) return;
        const groups = readGroups();
        const keys = Object.keys(groups);
        sel.innerHTML = '';
        if (keys.length === 0) {
            const opt = document.createElement('option'); opt.value = CONFIG.DEFAULT_GROUP; opt.textContent = CONFIG.DEFAULT_GROUP; sel.appendChild(opt);
        } else {
            keys.forEach(k => { const opt = document.createElement('option'); opt.value = k; opt.textContent = k; sel.appendChild(opt); });
        }
    }

    // --- csoportkezelő dialógus ---
    function openGroupManagerDialog() {
        // ha már van dialog, fókuszáljuk
        if (document.getElementById('tm-group-manager')) {
            document.getElementById('tm-group-manager').style.display = 'block';
            return;
        }

        const dlg = document.createElement('div');
        dlg.id = 'tm-group-manager';
        dlg.style.cssText = 'position:fixed;top:60px;right:60px;background:#fff;border:1px solid #ccc;padding:12px;z-index:20002;width:360px;max-height:70vh;overflow:auto;font-family:Arial,Helvetica,sans-serif;box-shadow:0 6px 20px rgba(0,0,0,0.2)';

        const title = document.createElement('h3'); title.textContent = 'Csoportok és nevek kezelése'; title.style.marginTop = '0';
        dlg.appendChild(title);

        // input + gombok új csoport létrehozáshoz
        const addRow = document.createElement('div'); addRow.style.cssText = 'display:flex;gap:6px;margin-bottom:8px';
        const newGroupInput = document.createElement('input'); newGroupInput.placeholder = 'Új csoport neve...'; newGroupInput.style.cssText = 'flex:1;padding:6px';
        const addGroupBtn = document.createElement('button'); addGroupBtn.textContent = 'Csoport +'; addGroupBtn.style.cssText = 'padding:6px';
        addRow.appendChild(newGroupInput); addRow.appendChild(addGroupBtn);
        dlg.appendChild(addRow);

        // konténer a csoportok listájának
        const groupsList = document.createElement('div');
        dlg.appendChild(groupsList);

        // gomb bezáráshoz
        const footer = document.createElement('div'); footer.style.cssText = 'display:flex;justify-content:flex-end;gap:8px;margin-top:10px';
        const saveBtn = document.createElement('button'); saveBtn.textContent = 'Mentés'; saveBtn.style.cssText = 'padding:6px 10px;background:#205081;color:white;border:none;border-radius:4px';
        const closeBtn = document.createElement('button'); closeBtn.textContent = 'Bezár'; closeBtn.style.cssText = 'padding:6px 10px';
        footer.appendChild(saveBtn); footer.appendChild(closeBtn);
        dlg.appendChild(footer);

        // lista render
        function renderGroupsEditor() {
            groupsList.innerHTML = '';
            const groups = readGroups();
            const keys = Object.keys(groups);
            if (keys.length === 0) {
                const p = document.createElement('p'); p.textContent = 'Nincsenek csoportok. Hozz létre egyet!'; groupsList.appendChild(p);
            }
            keys.forEach(g => {
                const card = document.createElement('div'); card.style.cssText = 'border:1px solid #e0e0e0;padding:8px;margin-bottom:8px;border-radius:4px;background:#fafafa';
                const hdr = document.createElement('div'); hdr.style.cssText = 'display:flex;align-items:center;gap:6px;margin-bottom:6px';
                const nameInput = document.createElement('input'); nameInput.value = g; nameInput.style.cssText = 'flex:1;padding:6px';
                const renameBtn = document.createElement('button'); renameBtn.textContent = 'Átnevez'; renameBtn.style.cssText = 'padding:6px';
                const deleteGroupBtn = document.createElement('button'); deleteGroupBtn.textContent = 'Csoport törlése'; deleteGroupBtn.style.cssText = 'padding:6px;color:#fff;background:#c0392b;border:none;border-radius:3px';
                hdr.appendChild(nameInput); hdr.appendChild(renameBtn); hdr.appendChild(deleteGroupBtn);
                card.appendChild(hdr);

                // nevek textarea (egyszerre több név is beírható, soronként)
                const namesArea = document.createElement('textarea');
                namesArea.style.cssText = 'width:100%;height:80px;padding:6px;font-family:monospace';
                namesArea.placeholder = 'Írd be a neveket, egy név soronként';
                namesArea.value = (groups[g] || []).join('\n');
                card.appendChild(namesArea);

                // gombok sor: mentés névhez, törlés név
                const row = document.createElement('div'); row.style.cssText = 'display:flex;gap:6px;margin-top:6px;justify-content:flex-end';
                const saveNamesBtn = document.createElement('button'); saveNamesBtn.textContent = 'Nevek mentése'; saveNamesBtn.style.cssText = 'padding:6px;background:#2d6ca2;color:white;border:none;border-radius:3px';
                const loadNamesBtn = document.createElement('button'); loadNamesBtn.textContent = 'Betöltés (kódhoz)'; loadNamesBtn.title = 'A nevek beírása a kód által használt helyre (local compatibility)'; loadNamesBtn.style.cssText = 'padding:6px';
                row.appendChild(loadNamesBtn); row.appendChild(saveNamesBtn);
                card.appendChild(row);

                // események
                renameBtn.addEventListener('click', () => {
                    const newName = nameInput.value.trim();
                    if (!newName) { alert('A csoport neve nem lehet üres'); return; }
                    if (newName === g) { alert('Ugyanaz a név, nincs változás'); return; }
                    const groupsObj = readGroups();
                    if (groupsObj[newName]) { alert('Már létezik ilyen nevű csoport'); return; }
                    groupsObj[newName] = groupsObj[g];
                    delete groupsObj[g];
                    writeGroups(groupsObj);
                    refreshGroupSelectOptions();
                    renderGroupsEditor();
                });

                deleteGroupBtn.addEventListener('click', () => {
                    if (!confirm(`Biztosan törlöd a "${g}" csoportot?`)) return;
                    const groupsObj = readGroups();
                    delete groupsObj[g];
                    writeGroups(groupsObj);
                    refreshGroupSelectOptions();
                    renderGroupsEditor();
                });

                saveNamesBtn.addEventListener('click', () => {
                    const txt = namesArea.value || '';
                    const arr = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                    const groupsObj = readGroups();
                    groupsObj[g] = arr;
                    writeGroups(groupsObj);
                    refreshGroupSelectOptions();
                    showToast('Nevek elmentve (' + arr.length + ')');
                });

                loadNamesBtn.addEventListener('click', () => {
                    const groupsObj = readGroups();
                    const arr = groupsObj[g] || [];
                    // ide írjuk a kompatibilis régi NAMES_STORAGE_KEY helyre
                    localStorage.setItem(CONFIG.NAMES_STORAGE_KEY, arr.join('\n'));
                    showToast('Nevek betöltve a kód által használt helyre (' + arr.length + ')');
                });

                groupsList.appendChild(card);
            });
        }

        // új csoport hozzáadása
        addGroupBtn.addEventListener('click', () => {
            const name = newGroupInput.value.trim();
            if (!name) { alert('Adj meg egy csoport nevet'); return; }
            const groupsObj = readGroups();
            if (groupsObj[name]) { alert('Már létezik ilyen csoport'); return; }
            groupsObj[name] = [];
            writeGroups(groupsObj);
            newGroupInput.value = '';
            refreshGroupSelectOptions();
            renderGroupsEditor();
        });

        saveBtn.addEventListener('click', () => {
            // minden mező mentése már külön gombokra van kötve, de itt frissítjük a selectet és bezárjuk
            refreshGroupSelectOptions();
            dlg.style.display = 'none';
            showToast('Csoportok mentve');
        });

        closeBtn.addEventListener('click', () => { dlg.style.display = 'none'; });

        // initial render
        renderGroupsEditor();

        document.body.appendChild(dlg);
    }

    // --- MIGRÁLÁS régi formátumból (ha kell) ---
    migrateLegacyNames();

    // --- INICIALIZÁLÁS ---
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => { createControlButton(); });
    } else {
        createControlButton();
    }

})();
